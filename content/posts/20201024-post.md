+++
title = "Angular Observable State Store"
description = ""
type = ["posts","post"]
tags = [
    "development",
    "angular",
    "RX/JS",
    "state management"
]
date = "2020-10-24"
categories = [
    "Development",
    "Angular",
    "RX/JS",
    "State management"
]
series = ["Hugo 101"]
[ author ]
  name = "Erik van Appeldoorn"
+++
 
Managing state in an Angular application is not a trivial thing. I was looking into the Observable State Store pattern lately and found it quite appealing. As it is using the RX/JS library internally it tqkes some time to get how it is working, so I decided to build a simple observable state store to get more grip on this pattern.

### Key characteristics of the observable state store
- It is a central location for storing state
- No external libraries needed, just RX/JS
- State service can be injected with Dependecy Injection into Angular components 
- Contains a function to set the state
- Contains a function to get the state as an Observable stream

### Base class StateStoreServiceBase<T>

``` TypeScript
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { Observable } from 'rxjs/internal/Observable';

@Injectable({ providedIn: 'root' })
export class StateStoreServiceBase<T> {
  private _state$: BehaviorSubject<T>;

  protected constructor() {
    this._state$ = new BehaviorSubject(null);
  }

  public get value$(): Observable<T> {
    return this._state$.asObservable();
  }

  public setValue(value: T) {
    this._state$.next(value);
  }

  public get value(): T {
    return this._state$.value;
  }
}
```
 The core of this generic service is this internal field:

 `
private _state$: BehaviorSubject<T>;
 `

The BehaviorSubject type is part of the RX/JS library and can be used as a publisher and subscriber. We can push new values into this object and also subscribe to the stream of values that are pushed. When we subscribe to it after values have been pushed we will get the lastest value, for more info on the BehaviorSubject take a look at [the offical RX/JS documentation](https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject ).

To push a new value into the store:

``` TypeScript
  public setValue(value: T) {
    this._state$.next(value);
  }
```

The store contains a function to get the pushed value as part of an Observable stream.

``` TypeScript
  public get value$(): Observable<T> {
    return this._state$.asObservable();
  }
```

The `asObserable()` function is used to convert the internal BehaviorSubject to an Observable, which makes it read-only for the consumers.

### Derived class: The NumberStateStoreService

``` TypeScript
import { Injectable } from '@angular/core';
import { StateStoreServiceBase } from './state-store-service-base.service';

@Injectable({ providedIn: 'root' })
export class NumberStateStoreService extends StateStoreServiceBase<number> {
}
```

This service is an implementation of the observable state store for holding numbers. 

To demonstrate how we can use this store I injected it into a component. The component holds a button and the click event handler of the button is used to increment the value in the store and it is using data binding in the view to display the actual value. It is an simple example but remember we can inject this service into multiple components to get the real power out of it.

``` TypeScript
import { Component } from '@angular/core';
import { Observable } from 'rxjs';
import { NumberStateStoreService } from 'src/services/number-state-store-service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'ObservableStateStore';
  constructor(private numberStateStoreService: NumberStateStoreService) {
    this.numberStateStoreService.setValue(0);
  }
  
  public increment(): void {
     let value: number = this.numberStateStoreService.value;
     value++;
     this.numberStateStoreService.setValue(value);
  }

  public get value$(): Observable<number> {
    return this.numberStateStoreService.value$;
  }
}
```
And the view:

``` HTML
<button (click)="increment()">Add One</button>
<h1>{{ value$ | async }}</h1>
```

 So we ended up with a basic, clean and extendable solution to get state out of the components and store it in a centralized observable state service. I have the feeling I am just scratching the surface right here but hope it helps you as well understanding more of state management in Angular.








