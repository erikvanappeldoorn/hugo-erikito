+++
title = "The Angular RX/JS refresh pattern"
description = ""
type = ["posts","post"]
tags = [
    "development",
    "angular",
    "RX/JS"
]
date = "2020-07-10"
categories = [
    "Development",
    "Angular",
    "RX/JS"
]
series = ["Hugo 101"]
[ author ]
  name = "Erik van Appeldoorn"
+++
 
In Angular the results of asynchronous HTTP API calls return `Observable<T>` objects. Any operation on that data is done by using the great powers of the [RX/JS](https://github.com/ReactiveX/rxjs) library.    

It is worthwhile to invest some time learning RX/JS. 
[Learn RXJS](https://www.learnrxjs.io) is a great starting point. 

But... Reactive programming wih RX/JS isn't straight forward and the huge number of very powerful RX/JS operators can make it quite an adventure to find the right solution for your use case.

Next to this, I like to have my code clean and crispy. Loads of RX/JS operators in a single RX/JS subscription with multiple side-effects is just something I prefer to avoid. Readability and simplicity is king, also in this RX/JS world.

Luckily we don't have to invent the wheel ourselves all the time. Design Patterns will give us some standard or best-practise solutions for common use cases. In this post I would like to focus on the refresh pattern in Angular and RX/JS.

### The pattern

So let's say we are using an Anguar service with a function returning `Observable<Person[]>` objects using a `http.get<Person[]>(...)` API call. 

I prefer to subscribe to the Observable as late as possible using the built-in Angular `async` pipe. Angular takes care of unsubscribing the subscription, which makes the `async` pipe very convenient. So maybe our component will look something like this:

``` TypeScript
@Component({
  selector: 'app-persons',
  template: `<ng-container *ngIf="persons$ | async as persons">
               <ul>
                 <li *ngFor="let person of persons">
                   <h1>{{ person.fullname }}</h1>
                 </li> 
               </ul> 
             </ng-container>`
})   
```
Normally we just fetch the data once directly in the `ngOnInit` component event handler. But it gets more complicated when additional logic is needed. 

So for example what if the component has a delete button to delete a person or multiple persons from the server-side state using the API? We need to fetch the Web API again afterwards for a refreshed list of persons. 

The Angular RX/JS refresh pattern is a nice little pattern to solve this on a very nice effective way.

``` TypeScript
private readonly refreshTrigger$ = new BehaviourSubject(undefined);

public readonly persons$ = refreshTrigger$.
  pipe(
    switchMap(() => this.http.get<Person[]>(...))
  );
```
By using this code the `persons$` field will be initialized by the result of the `http.get` call without any further logic needed. It will be triggered automatically by the instantiation of the `refreshTrigger$` field. And remember we don't have to subscribe on `persons$`, this will be handled by the `async` pipe of the template. 

So whenever we perform updates and want to refresh `persons$` in the component logic there is just one additional line of code needed:

``` TypeScript
this.refreshTrigger$.next(undefined)
```
We just push a new value (undefined) in the `BehaviourSubject` this will trigger the refresh and Angular binding will do the user interface updates, simple and neat.